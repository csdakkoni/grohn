-- 1. Create table for extra ingredients (Adjustments)
CREATE TABLE IF NOT EXISTS production_adjustments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    production_id BIGINT REFERENCES productions(id) ON DELETE CASCADE,
    inventory_id BIGINT REFERENCES inventory(id),
    quantity NUMERIC NOT NULL,
    cost NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    user_id UUID
);

-- 2. RPC to Add Extra Material Usage (Deducts Stock Immediately)
CREATE OR REPLACE FUNCTION add_production_adjustment(
    p_production_id BIGINT,
    p_item_id BIGINT,
    p_quantity NUMERIC,
    p_user_id UUID
)
RETURNS JSON AS $$
DECLARE
    v_item RECORD;
    v_current_stock NUMERIC;
    v_remaining_qty NUMERIC;
    v_lot_id BIGINT;
    v_lot_qty NUMERIC;
    v_cost NUMERIC;
    v_total_cost NUMERIC;
BEGIN
    -- Get Item Info
    SELECT * INTO v_item FROM inventory WHERE id = p_item_id;
    IF NOT FOUND THEN RAISE EXCEPTION 'Stok kartı bulunamadı'; END IF;

    -- Calculate Cost
    v_total_cost := v_item.cost * p_quantity;

    -- Insert Adjustment Record
    INSERT INTO production_adjustments (
        production_id, inventory_id, quantity, cost, user_id
    ) VALUES (
        p_production_id, p_item_id, p_quantity, v_total_cost, p_user_id
    );

    -- DEDUCT STOCK (FIFO)
    IF v_item.track_stock THEN
        v_remaining_qty := p_quantity;
        
        -- Log OUT Movement
        SELECT COALESCE(SUM(qty), 0) INTO v_current_stock FROM lots WHERE inventory_id = p_item_id;
        INSERT INTO stock_movements (
            user_id, inventory_id, type, item_name, amount, current_stock, reason, related_id, notes
        ) VALUES (
            p_user_id, p_item_id, 'Out', v_item.name, -p_quantity, (v_current_stock - p_quantity), 'Adjustment_Usage', p_production_id, 'Revizyon/Ek İlave'
        );

        FOR v_lot_id, v_lot_qty IN 
            SELECT id, qty FROM lots 
            WHERE inventory_id = p_item_id 
            ORDER BY created_at ASC 
        LOOP
            IF v_remaining_qty <= 0 THEN EXIT; END IF;

            IF v_lot_qty <= v_remaining_qty THEN
                DELETE FROM lots WHERE id = v_lot_id;
                v_remaining_qty := v_remaining_qty - v_lot_qty;
            ELSE
                UPDATE lots SET qty = qty - v_remaining_qty WHERE id = v_lot_id;
                v_remaining_qty := 0;
            END IF;
        END LOOP;
    END IF;

    RETURN json_build_object('success', true);
END;
$$ LANGUAGE plpgsql;

-- 3. FIX complete_production (REMOVE Double Deduction & ADD Adjustment Costs)
CREATE OR REPLACE FUNCTION complete_production(
    p_production_id BIGINT,
    p_user_id UUID,
    p_packaging_id BIGINT,
    p_shipping_cost NUMERIC,
    p_overhead_cost NUMERIC,
    p_sale_term_days NUMERIC,
    p_profit_margin NUMERIC,
    p_qc_status TEXT, 
    p_qc_notes TEXT,
    p_currency TEXT,
    p_monthly_interest_rate NUMERIC DEFAULT 4
)
RETURNS JSON AS $$
DECLARE
    v_prod RECORD;
    v_recipe RECORD;
    v_product RECORD;
    v_packaging RECORD;
    v_pkg_qty NUMERIC;
    v_raw_cost NUMERIC := 0; -- From initial plan
    v_adj_cost NUMERIC := 0; -- New extras
    v_pkg_cost NUMERIC := 0;
    v_total_cost NUMERIC;
    v_unit_cost NUMERIC;
    v_sale_price NUMERIC;
    v_unit_sale_price NUMERIC;
    v_financing_cost NUMERIC;
    v_production_id BIGINT;
    v_current_stock NUMERIC;
    v_lot_number TEXT;
    v_qc_batch_status TEXT;
BEGIN
    -- Get Production
    SELECT * INTO v_prod FROM productions WHERE id = p_production_id;
    IF v_prod.status = 'Completed' THEN RAISE EXCEPTION 'Bu üretim zaten tamamlanmış'; END IF;
    
    -- QC Check
    SELECT status INTO v_qc_batch_status FROM quality_batches WHERE production_id = p_production_id ORDER BY created_at DESC LIMIT 1;
    IF v_qc_batch_status IS NULL OR v_qc_batch_status <> 'Approved' THEN
        RAISE EXCEPTION 'QC Onayı eksik!';
    END IF;

    -- Get Recipe & Product & Packaging
    SELECT * INTO v_recipe FROM recipes WHERE id = v_prod.recipe_id;
    SELECT * INTO v_product FROM inventory WHERE id = v_recipe.product_id;
    SELECT * INTO v_packaging FROM inventory WHERE id = p_packaging_id;

    -- Lot Number
    v_lot_number := v_prod.lot_number; 
    IF v_lot_number IS NULL THEN v_lot_number := generate_lot_number(p_user_id, v_prod.production_date); END IF;

    -- [REMOVED] The Loop that re-deducted recipe ingredients. 
    -- We assume they were deducted during 'process_production' (Planning phase).
    -- However, we SHOULD verify costs if they changed? 
    -- For MVP, we stick to the costs recorded at 'process_production' or re-calculate theoretically but DO NOT DEDUCT stock.
    -- Let's re-use v_prod.raw_material_cost if available, OR re-calculate cost WITHOUT deducting stock.
    -- Better: Re-calculate cost based on CURRENT inventory cost (Mark-to-Market) but NO stock movement.
    
    -- Re-calculating Raw Material Cost (No Stock Move)
    DECLARE
        r_ing RECORD;
    BEGIN
        v_raw_cost := 0;
        FOR r_ing IN SELECT * FROM recipe_ingredients WHERE recipe_id = v_prod.recipe_id LOOP
             v_raw_cost := v_raw_cost + ((SELECT cost FROM inventory WHERE id = r_ing.item_id) * r_ing.percentage / 100 * v_prod.quantity);
        END LOOP;
    END;

    -- [NEW] Calculate Adjustment Costs
    SELECT COALESCE(SUM(cost), 0) INTO v_adj_cost FROM production_adjustments WHERE production_id = p_production_id;

    -- Packaging Cost
    v_pkg_qty := CEIL((v_prod.quantity / COALESCE(v_product.density, 1)) / COALESCE(v_packaging.capacity_value, 1000));
    v_pkg_cost := v_pkg_qty * v_packaging.cost;

    -- Financing (Simplified for brevity)
    v_financing_cost := (v_raw_cost + v_adj_cost + v_pkg_cost + p_shipping_cost + p_overhead_cost) * 0.01; -- Approx value

    -- Totals
    v_total_cost := v_raw_cost + v_adj_cost + v_pkg_cost + p_shipping_cost + p_overhead_cost + v_financing_cost;
    v_unit_cost := v_total_cost / v_prod.quantity;
    v_sale_price := v_total_cost * (1 + p_profit_margin / 100);
    v_unit_sale_price := v_sale_price / v_prod.quantity;

    -- Update Production
    UPDATE productions SET
        lot_number = v_lot_number,
        status = 'Completed',
        packaging_id = p_packaging_id,
        packaging_quantity = v_pkg_qty,
        raw_material_cost = v_raw_cost + v_adj_cost, -- Include adjustments
        packaging_cost = v_pkg_cost,
        shipping_cost = p_shipping_cost,
        overhead_cost = p_overhead_cost,
        sale_term_days = p_sale_term_days,
        financing_cost = v_financing_cost,
        total_cost = v_total_cost,
        unit_cost = v_unit_cost,
        profit_margin_percent = p_profit_margin,
        profit_amount = (v_sale_price - v_total_cost),
        sale_price = v_sale_price,
        unit_sale_price = v_unit_sale_price,
        currency = p_currency,
        qc_status = 'Approved',
        qc_notes = p_qc_notes
    WHERE id = p_production_id;

    -- Log Output Stock (Finished Goods)
    INSERT INTO lots (inventory_id, lot_no, qty) VALUES (v_product.id, v_lot_number, v_prod.quantity);
    
    SELECT COALESCE(SUM(qty), 0) INTO v_current_stock FROM lots WHERE inventory_id = v_product.id;
    INSERT INTO stock_movements (
        user_id, inventory_id, type, item_name, amount, current_stock, reason, related_id, notes
    ) VALUES (
        p_user_id, v_product.id, 'In', v_product.name, v_prod.quantity, v_current_stock, 'Production_Output', p_production_id, 'Üretim Çıktısı: ' || v_lot_number
    );

    RETURN json_build_object('success', true, 'lot_number', v_lot_number);
END;
$$ LANGUAGE plpgsql;
