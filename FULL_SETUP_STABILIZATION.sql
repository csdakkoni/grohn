
-- ==========================================================
-- FULL DATABASE STABILIZATION & RPC SETUP
-- Consolidated from latest stable scripts.
-- ==========================================================

BEGIN;

-- 1. Ensure Inventory Schema is Complete
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS product_code TEXT;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS ghs_symbols TEXT[] DEFAULT '{}';
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS shelf_life_months INTEGER DEFAULT 24;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS ref_overhead_cost NUMERIC DEFAULT 0;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS ref_packaging_id INTEGER REFERENCES inventory(id);
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS ref_shipping_cost NUMERIC DEFAULT 0;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS ref_monthly_interest NUMERIC DEFAULT 4;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS capacity_value NUMERIC;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS capacity_unit TEXT;
ALTER TABLE inventory ADD COLUMN IF NOT EXISTS tare_weight NUMERIC;

-- 2. Ensure Quality Schema
CREATE TABLE IF NOT EXISTS quality_standards (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='quality_batches' AND column_name='production_id') THEN
        ALTER TABLE quality_batches ADD COLUMN production_id BIGINT REFERENCES productions(id);
    END IF;
END $$;

-- 3. HELPER: generate_lot_number
CREATE OR REPLACE FUNCTION generate_lot_number(p_user_id UUID, p_date DATE)
RETURNS TEXT AS $$
DECLARE
    date_str TEXT;
    seq INTEGER;
    new_lot TEXT;
BEGIN
    date_str := to_char(p_date, 'DDMMYY');
    SELECT COALESCE(MAX(CAST(SPLIT_PART(lot_number, '-', 3) AS INTEGER)), 0) + 1
    INTO seq
    FROM productions
    WHERE user_id = p_user_id
    AND lot_number LIKE 'GR-' || date_str || '-%';
    new_lot := 'GR-' || date_str || '-' || LPAD(seq::TEXT, 2, '0');
    RETURN new_lot;
END;
$$ LANGUAGE plpgsql;

-- 4. RPC: process_purchase
CREATE OR REPLACE FUNCTION process_purchase(
    p_user_id UUID,
    p_supplier_id BIGINT,
    p_item_name TEXT,
    p_item_type TEXT,
    p_unit TEXT,
    p_qty NUMERIC,
    p_price NUMERIC,
    p_currency TEXT,
    p_term_days NUMERIC,
    p_lot_no TEXT,
    p_is_new_item BOOLEAN,
    p_item_id BIGINT DEFAULT NULL,
    p_capacity_value NUMERIC DEFAULT NULL,
    p_capacity_unit TEXT DEFAULT NULL,
    p_tare_weight NUMERIC DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_inventory_id BIGINT;
    v_purchase_id BIGINT;
    v_total_amount NUMERIC;
    v_current_stock NUMERIC;
BEGIN
    v_total_amount := p_qty * p_price;
    IF p_is_new_item THEN
        INSERT INTO inventory (
            user_id, name, type, unit, cost, currency, payment_term, track_stock,
            capacity_value, capacity_unit, tare_weight
        ) VALUES (
            p_user_id, p_item_name, p_item_type, p_unit, p_price, p_currency, p_term_days, TRUE,
            p_capacity_value, p_capacity_unit, p_tare_weight
        ) RETURNING id INTO v_inventory_id;
        UPDATE inventory SET
             product_code = CASE 
                WHEN p_item_type = 'Hammadde' THEN 'HM-' || LPAD(v_inventory_id::text, 3, '0')
                WHEN p_item_type = 'Ambalaj' THEN 'AMB-' || LPAD(v_inventory_id::text, 3, '0')
                ELSE 'ITEM-' || LPAD(v_inventory_id::text, 3, '0')
             END
        WHERE id = v_inventory_id;
    ELSE
        v_inventory_id := p_item_id;
        UPDATE inventory SET cost = p_price, currency = p_currency, payment_term = p_term_days WHERE id = v_inventory_id;
    END IF;
    INSERT INTO lots (inventory_id, lot_no, qty) VALUES (v_inventory_id, p_lot_no, p_qty);
    INSERT INTO purchases (user_id, supplier_id, item_name, qty, price, currency, total, payment_term, lot_no)
    VALUES (p_user_id, p_supplier_id, p_item_name, p_qty, p_price, p_currency, v_total_amount, p_term_days, p_lot_no)
    RETURNING id INTO v_purchase_id;
    SELECT COALESCE(SUM(qty), 0) INTO v_current_stock FROM lots WHERE inventory_id = v_inventory_id;
    INSERT INTO stock_movements (user_id, inventory_id, type, item_name, amount, current_stock, reason, related_id, notes)
    VALUES (p_user_id, v_inventory_id, 'In', p_item_name, p_qty, v_current_stock, 'Purchase', v_purchase_id, 'Satınalma: ' || p_lot_no);
    RETURN json_build_object('success', true, 'purchase_id', v_purchase_id);
END;
$$ LANGUAGE plpgsql;

-- 5. RPC: process_production
CREATE OR REPLACE FUNCTION process_production(
    p_user_id UUID, p_recipe_id BIGINT, p_quantity NUMERIC, p_production_date DATE,
    p_packaging_id BIGINT, p_shipping_cost NUMERIC, p_overhead_cost NUMERIC,
    p_sale_term_days NUMERIC, p_profit_margin NUMERIC, p_notes TEXT,
    p_currency TEXT, p_customer_id BIGINT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_recipe RECORD; v_product RECORD; v_packaging RECORD; v_ingredient RECORD;
    v_lot_number TEXT; v_raw_cost NUMERIC := 0; v_pkg_cost NUMERIC := 0;
    v_pkg_qty NUMERIC; v_total_cost NUMERIC; v_unit_cost NUMERIC;
    v_sale_price NUMERIC; v_unit_sale_price NUMERIC; v_financing_cost NUMERIC;
    v_pay_term_sum NUMERIC := 0; v_cost_sum NUMERIC := 0; v_avg_term NUMERIC;
    v_fin_days NUMERIC; v_production_id BIGINT; v_remaining_qty NUMERIC;
    v_lot_qty NUMERIC; v_lot_id BIGINT; v_current_stock NUMERIC; v_item_name TEXT;
    v_ingredient_track_stock BOOLEAN;
BEGIN
    SELECT * INTO v_recipe FROM recipes WHERE id = p_recipe_id;
    IF NOT FOUND THEN RAISE EXCEPTION 'Reçete bulunamadı'; END IF;
    SELECT * INTO v_product FROM inventory WHERE id = v_recipe.product_id;
    SELECT * INTO v_packaging FROM inventory WHERE id = p_packaging_id;
    FOR v_ingredient IN SELECT * FROM recipe_ingredients WHERE recipe_id = p_recipe_id LOOP
        DECLARE
            v_item_cost NUMERIC; v_req_qty NUMERIC; v_avail_qty NUMERIC; v_item_term NUMERIC; v_track_stock BOOLEAN;
        BEGIN
            SELECT cost, payment_term, track_stock INTO v_item_cost, v_item_term, v_track_stock FROM inventory WHERE id = v_ingredient.item_id;
            v_raw_cost := v_raw_cost + (v_item_cost * v_ingredient.percentage/100 * p_quantity);
            v_pay_term_sum := v_pay_term_sum + (v_item_cost * v_ingredient.percentage/100 * p_quantity * COALESCE(v_item_term, 0));
            v_cost_sum := v_cost_sum + (v_item_cost * v_ingredient.percentage/100 * p_quantity);
            v_req_qty := (p_quantity * v_ingredient.percentage/100);
            IF v_track_stock THEN
                SELECT COALESCE(SUM(qty), 0) INTO v_avail_qty FROM lots WHERE inventory_id = v_ingredient.item_id;
                IF v_avail_qty < v_req_qty THEN RAISE EXCEPTION 'Yetersiz stok: Item ID %', v_ingredient.item_id; END IF;
            END IF;
        END;
    END LOOP;
    v_pkg_qty := CEIL((p_quantity / COALESCE(v_product.density, 1)) / COALESCE(v_packaging.capacity_value, 1000));
    v_pkg_cost := v_pkg_qty * v_packaging.cost;
    v_avg_term := CASE WHEN v_cost_sum > 0 THEN v_pay_term_sum / v_cost_sum ELSE 0 END;
    v_fin_days := GREATEST(0, p_sale_term_days - v_avg_term);
    v_financing_cost := (v_raw_cost + v_pkg_cost + p_shipping_cost + p_overhead_cost) * (0.04 / 30) * v_fin_days;
    v_total_cost := v_raw_cost + v_pkg_cost + p_shipping_cost + p_overhead_cost + v_financing_cost;
    v_unit_cost := v_total_cost / p_quantity;
    v_sale_price := v_total_cost * (1 + p_profit_margin / 100);
    v_unit_sale_price := v_sale_price / p_quantity;
    v_lot_number := generate_lot_number(p_user_id, p_production_date);
    INSERT INTO productions (user_id, recipe_id, lot_number, quantity, production_date, packaging_id, packaging_quantity, raw_material_cost, packaging_cost, shipping_cost, overhead_cost, sale_term_days, financing_cost, total_cost, unit_cost, profit_margin_percent, profit_amount, sale_price, unit_sale_price, currency, notes, customer_id)
    VALUES (p_user_id, p_recipe_id, v_lot_number, p_quantity, p_production_date, p_packaging_id, v_pkg_qty, v_raw_cost, v_pkg_cost, p_shipping_cost, p_overhead_cost, p_sale_term_days, v_financing_cost, v_total_cost, v_unit_cost, p_profit_margin, (v_sale_price - v_total_cost), v_sale_price, v_unit_sale_price, p_currency, p_notes, p_customer_id)
    RETURNING id INTO v_production_id;
    FOR v_ingredient IN SELECT * FROM recipe_ingredients WHERE recipe_id = p_recipe_id LOOP
        v_remaining_qty := (p_quantity * v_ingredient.percentage/100);
        SELECT name, track_stock INTO v_item_name, v_ingredient_track_stock FROM inventory WHERE id = v_ingredient.item_id;
        IF v_ingredient_track_stock THEN
            SELECT COALESCE(SUM(qty), 0) - v_remaining_qty INTO v_current_stock FROM lots WHERE inventory_id = v_ingredient.item_id;
            INSERT INTO stock_movements (user_id, inventory_id, type, item_name, amount, current_stock, reason, related_id, notes)
            VALUES (p_user_id, v_ingredient.item_id, 'Out', v_item_name, -v_remaining_qty, v_current_stock, 'Production_Usage', v_production_id, 'Üretim: ' || v_lot_number);
            FOR v_lot_id, v_lot_qty IN SELECT id, qty FROM lots WHERE inventory_id = v_ingredient.item_id ORDER BY created_at ASC LOOP
                IF v_remaining_qty <= 0 THEN EXIT; END IF;
                IF v_lot_qty <= v_remaining_qty THEN DELETE FROM lots WHERE id = v_lot_id; v_remaining_qty := v_remaining_qty - v_lot_qty;
                ELSE UPDATE lots SET qty = qty - v_remaining_qty WHERE id = v_lot_id; v_remaining_qty := 0; END IF;
            END LOOP;
        END IF;
    END LOOP;
    INSERT INTO lots (inventory_id, lot_no, qty) VALUES (v_product.id, v_lot_number, p_quantity);
    SELECT COALESCE(SUM(qty), 0) INTO v_current_stock FROM lots WHERE inventory_id = v_product.id;
    INSERT INTO stock_movements (user_id, inventory_id, type, item_name, amount, current_stock, reason, related_id, notes)
    VALUES (p_user_id, v_product.id, 'In', v_product.name, p_quantity, v_current_stock, 'Production_Output', v_production_id, 'Üretim Çıktısı: ' || v_lot_number);
    RETURN json_build_object('id', v_production_id, 'lot_number', v_lot_number);
END;
$$ LANGUAGE plpgsql;

-- 6. RPC: process_sale
CREATE OR REPLACE FUNCTION process_sale(
    p_user_id UUID, p_customer_id BIGINT, p_production_id BIGINT, p_quantity NUMERIC,
    p_unit_price NUMERIC, p_currency TEXT, p_payment_term NUMERIC, p_sale_date DATE, p_notes TEXT
)
RETURNS BIGINT AS $$
DECLARE
    v_production RECORD; v_recipe RECORD; v_product_id BIGINT; v_avail_qty NUMERIC;
    v_remaining_qty NUMERIC; v_lot_id BIGINT; v_lot_qty NUMERIC; v_sale_id BIGINT;
    v_current_stock NUMERIC; v_product_name TEXT;
BEGIN
    SELECT * INTO v_production FROM productions WHERE id = p_production_id;
    IF NOT FOUND THEN RAISE EXCEPTION 'Üretim kaydı bulunamadı'; END IF;
    SELECT * INTO v_recipe FROM recipes WHERE id = v_production.recipe_id;
    v_product_id := v_recipe.product_id;
    SELECT name INTO v_product_name FROM inventory WHERE id = v_product_id;
    SELECT COALESCE(SUM(qty), 0) INTO v_avail_qty FROM lots WHERE inventory_id = v_product_id;
    IF v_avail_qty < p_quantity THEN RAISE EXCEPTION 'Yetersiz stok! Mevcut: %, İstenen: %', v_avail_qty, p_quantity; END IF;
    INSERT INTO sales (user_id, customer_id, production_id, product_name, lot_number, quantity, unit_price, currency, total_amount, sale_date, payment_term, notes)
    VALUES (p_user_id, p_customer_id, p_production_id, v_product_name, v_production.lot_number, p_quantity, p_unit_price, p_currency, (p_quantity * p_unit_price), p_sale_date, p_payment_term, p_notes)
    RETURNING id INTO v_sale_id;
    v_remaining_qty := p_quantity;
    FOR v_lot_id, v_lot_qty IN SELECT id, qty FROM lots WHERE inventory_id = v_product_id ORDER BY created_at ASC LOOP
        IF v_remaining_qty <= 0 THEN EXIT; END IF;
        IF v_lot_qty <= v_remaining_qty THEN DELETE FROM lots WHERE id = v_lot_id; v_remaining_qty := v_remaining_qty - v_lot_qty;
        ELSE UPDATE lots SET qty = qty - v_remaining_qty WHERE id = v_lot_id; v_remaining_qty := 0; END IF;
    END LOOP;
    SELECT COALESCE(SUM(qty), 0) INTO v_current_stock FROM lots WHERE inventory_id = v_product_id;
    INSERT INTO stock_movements (user_id, inventory_id, type, item_name, amount, current_stock, reason, related_id, notes)
    VALUES (p_user_id, v_product_id, 'Out', v_product_name, -p_quantity, v_current_stock, 'Sale', v_sale_id, 'Satış: ' || v_production.lot_number);
    RETURN v_sale_id;
END;
$$ LANGUAGE plpgsql;

COMMIT;
